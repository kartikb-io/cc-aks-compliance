
## 2. Policies

## Labels

### Label Examples

## Policy Tiers

Why are policy tiers important for Compliance?

### Policy Tier Examples

```yaml
apiVersion: projectcalico.org/v3
kind: Tier
metadata:
  name: security
spec:
  order: 300
---
apiVersion: projectcalico.org/v3
kind: Tier
metadata:
  name: platform
spec:
  order: 200
---
apiVersion: projectcalico.org/v3
kind: Tier
metadata:
  name: application
spec:
  order: 400
```

### Policy Examples

#### PCI 

```yaml
apiVersion: projectcalico.org/v3
kind: GlobalNetworkPolicy
metadata:
  name: default.pci
spec:
  tier: default
  order: 0
  selector: pci == "ok"
  namespaceSelector: ''
  serviceAccountSelector: ''
  ingress:
    - action: Allow
      source:
        selector: pci == "ok"
      destination: {}
    - action: Deny
      source:
        selector: pci != "ok"
      destination: {}
  egress:
    - action: Allow
      source: {}
      destination:
        selector: pci == "ok"
    - action: Deny
      source: {}
      destination:
        selector: pci != "ok"
  doNotTrack: false
  applyOnForward: false
  preDNAT: false
  types:
    - Ingress
    - Egress
```

#### NameSpace Isolation

*Notice the use of the broad scope scd , which matches all pods belonging to those tenants. We could have likewise used namespaceSelector == "tenant1", which can be a better approach if you think about it from a RBAC perspective, where the platform team manages namespace provisioning and labeling, while developers manage deployments to their authorised namespaces and pod labels.*

*What this is actually doing is delegating (passing) controls for tenant1 to the application tier after implementing high-level security controls at the security tier level. High level security controls are typically implemented through enterprise security guidelines and compliance requirements for intra-cluster and external communication. At the application tier level, granular microsegmentation would be implmentated by developers to secure microservices.*

*It is important here to understand the policy processing behavior of Calico Enterprise:*

*The default action for selected endpoint within a policy tier is Deny
The default action for non-selected endpoint within a policy tier is Pass
Pass action happens at the end of a policy tier
This means that for any selected endpoints in a policy tier, communication that is not explicitly permitted or passed is denied. This means that in the very simple policy we have implemented, we have effectively isolated tenant1 and tenant2. Communication for tenant1 for example outside the scope of its own tenant is denied since we're selecting tenant1 and only passing communication with its own tenant. Notice the default deny at the security tier effectively enforces organisation controls including multi-tenancy. Whatever is not passed or allowed is denied.*

*Take a moment and reflect on how it would have entailed to implement the same in a legacy infrastructure. The possibilities are simply unlimited!*

```yaml
apiVersion: projectcalico.org/v3
kind: GlobalNetworkPolicy
metadata:
  name: security.pass-tenant1
spec:
  tier: security
  order: 101
  selector: tenant == "tenant1"
  types:
  - Ingress
  ingress:
  - action: Allow
    protocol: TCP
    destination:
      selector: ingress == "true"
      ports:
      - 80
  - action: Pass
    destination:
      selector: tenant == "tenant1"
---
apiVersion: projectcalico.org/v3
kind: GlobalNetworkPolicy
metadata:
  name: security.pass-tenant2
spec:
  tier: security
  order: 102
  selector: tenant == "tenant2"
  types:
  - Ingress
  ingress:
  - action: Pass
    destination:
      selector: tenant == "tenant2"
---
apiVersion: projectcalico.org/v3
kind: GlobalNetworkPolicy
metadata:
  name: security.default-deny-security-tier
spec:
  tier: security
  order: 999999
  selector: all()
  types:
  - Ingress
  ingress:
  - action: Deny
```
